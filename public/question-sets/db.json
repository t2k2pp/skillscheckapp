{
  "id": "db",
  "title": "データベーススペシャリスト試験対策",
  "description": "データベーススペシャリスト試験の午前問題対策です。データベースシステム、データモデリング、SQL、パフォーマンス最適化、運用管理などの専門知識を問う問題を収録しています。",
  "categories": [
    "データベース設計",
    "SQL・クエリ最適化",
    "トランザクション管理",
    "性能・運用",
    "新技術・標準"
  ],
  "estimatedTime": "120分",
  "level": "上級",
  "totalQuestions": 75,
  "questions": [
    {
      "id": 1,
      "category": "データベース設計",
      "options": [
        "すべての非キー属性が主キーに完全関数従属",
        "すべての非キー属性が主キーに完全関数従属し、推移的関数従属がない",
        "複数値従属が存在しない",
        "結合従属が存在しない"
      ],
      "correctAnswerIndex": 1,
      "explanation": "第3正規形は、第2正規形の条件に加えて、非キー属性間の推移的関数従属が存在しないことが条件です。",
      "level": "基礎",
      "text": "正規化理論における第3正規形（3NF）の条件として適切なものはどれか。"
    },
    {
      "id": 2,
      "category": "SQL・クエリ最適化",
      "options": [
        "推定精度はクエリ性能に影響しない",
        "不正確な推定により非効率な実行計画が選択される可能性",
        "推定は常に正確で問題ない",
        "推定精度は統計情報に依存しない"
      ],
      "correctAnswerIndex": 1,
      "explanation": "カーディナリティ推定の精度は実行計画の選択に直接影響し、不正確な推定は非効率なJOIN順序やアクセス方法の選択につながります。",
      "level": "上級",
      "text": "SQL クエリオプティマイザーにおける「カーディナリティ推定」の精度がクエリ性能に与える影響として適切なものはどれか。"
    },
    {
      "id": 3,
      "category": "トランザクション管理",
      "options": [
        "トランザクションの原子性が保証されない",
        "コーディネーターが障害時にブロッキングが発生する可能性",
        "参加者間の通信が一切不要",
        "ロールバック機能が存在しない"
      ],
      "correctAnswerIndex": 1,
      "explanation": "2PCでは、第2フェーズでコーディネーターが障害に遭うと、参加者は決定を受け取るまで indefinitely にブロックされる可能性があります。",
      "level": "上級",
      "text": "分散データベースにおける「Two-Phase Commit（2PC）」プロトコルの課題として適切なものはどれか。"
    },
    {
      "id": 4,
      "category": "性能・運用",
      "options": [
        "すべての読み取りをマスターに向ける",
        "書き込み直後の読み取りをマスターにルーティング",
        "レプリケーション遅延を無視する",
        "Read Replica のみを使用する"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Read-after-Write Consistencyを保証するには、ユーザーが書き込んだ直後の読み取りクエリをマスターDB に向け、レプリケーション遅延の影響を回避します。",
      "level": "上級",
      "text": "データベースのRead Replica における「Read-after-Write Consistency」を保証する手法として適切なものはどれか。"
    },
    {
      "id": 5,
      "category": "新技術・標準",
      "options": [
        "ACID特性の保証",
        "水平スケーラビリティ",
        "SQL インターフェース",
        "結果整合性のみのサポート"
      ],
      "correctAnswerIndex": 3,
      "explanation": "NewSQLは、NoSQLのスケーラビリティと従来RDBMSのACID特性・SQL インターフェースを両立させ、強一貫性を提供します。",
      "level": "中級",
      "text": "NewSQL データベースの特徴として適切でないものはどれか。"
    },
    {
      "id": 6,
      "category": "データベース設計",
      "options": [
        "高い書き込みスループット",
        "時間範囲クエリの最適化",
        "複雑なJOIN操作の頻繁な実行",
        "データの圧縮とアーカイブ"
      ],
      "correctAnswerIndex": 2,
      "explanation": "時系列データベースは、時間軸でのデータ蓄積・分析に特化しており、複雑なJOIN操作よりも時間範囲での効率的なクエリが重要です。",
      "level": "上級",
      "text": "Time Series Database の設計において重要な考慮事項として適切でないものはどれか。"
    },
    {
      "id": 7,
      "category": "SQL・クエリ最適化",
      "options": [
        "クエリの構文エラー",
        "統計情報の古さやカーディナリティ推定の誤り",
        "トランザクション分離レベルの設定ミス",
        "インデックスの完全な欠如"
      ],
      "correctAnswerIndex": 1,
      "explanation": "実行時間と計画時間の大きな差は、オプティマイザーが使用する統計情報が古い、または不正確であることが主な原因です。",
      "level": "上級",
      "text": "PostgreSQL における「EXPLAIN ANALYZE」の出力で「actual time」と「planned time」に大きな差がある場合の原因として適切なものはどれか。"
    },
    {
      "id": 8,
      "category": "トランザクション管理",
      "options": [
        "行レベルロックの使用",
        "Predicate Lock または Serializable Snapshot Isolation",
        "読み取り専用トランザクションの使用",
        "トランザクション分離レベルの下げ"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Snapshot Isolation単体ではファントムリードを防げないため、Predicate Lock やSSI（Serializable Snapshot Isolation）が必要です。",
      "level": "上級",
      "text": "Multi-Version Concurrency Control（MVCC）における「Snapshot Isolation」のファントムリード対策として適切なものはどれか。"
    },
    {
      "id": 9,
      "category": "性能・運用",
      "options": [
        "プールサイズを無制限にする",
        "接続タイムアウトの設定と適切なリソース管理",
        "すべての接続を永続化する",
        "Connection Poolを使用しない"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Connection Leakを防ぐには、適切なタイムアウト設定、try-with-resources構文の使用、プール監視による早期検出が重要です。",
      "level": "中級",
      "text": "Database Connection Pooling における「Connection Leak」の対策として適切なものはどれか。"
    },
    {
      "id": 10,
      "category": "新技術・標準",
      "options": [
        "従来の関係データの管理",
        "埋め込みベクトルによる類似性検索とAI アプリケーション",
        "単純な文字列検索",
        "数値計算のみ"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Vector DatabaseはAI・機械学習で生成される埋め込みベクトルを効率的に保存・検索し、類似性検索やレコメンデーションシステムで活用されます。",
      "level": "上級",
      "text": "Vector Database の用途として最も適切なものはどれか。"
    },
    {
      "id": 11,
      "category": "データベース設計",
      "options": [
        "関係性の詳細情報を格納",
        "ビジネスキーとメタデータを格納",
        "履歴データの差分情報を格納",
        "集計データを格納"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Data Vault モデルでは、Hubがビジネスキー（顧客ID、製品IDなど）とメタデータを格納し、データの一意性を確保します。",
      "level": "上級",
      "text": "Data Vault 2.0 モデリング手法における「Hub」エンティティの役割として適切なものはどれか。"
    },
    {
      "id": 12,
      "category": "SQL・クエリ最適化",
      "options": [
        "現在行のみを対象とする",
        "先頭行から現在行までを対象とする",
        "現在行から最終行までを対象とする",
        "全行を対象とする"
      ],
      "correctAnswerIndex": 1,
      "explanation": "UNBOUNDED PRECEDING は先頭行、CURRENT ROW は現在行を示すため、パーティション内の先頭行から現在行までがフレームの範囲となります。",
      "level": "中級",
      "text": "Window Function におけるフレーム指定「ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW」の意味として適切なものはどれか。"
    },
    {
      "id": 13,
      "category": "トランザクション管理",
      "options": [
        "すべてのノードでの同期的更新",
        "非同期レプリケーションと競合解決戦略",
        "強い一貫性の常時保証",
        "データの更新を一切行わない"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Eventual Consistencyは、非同期レプリケーションにより、一定時間後にすべてのレプリカが同じ状態に収束することを保証するモデルです。",
      "level": "上級",
      "text": "分散データベースにおける「Eventual Consistency」を実現するアプローチとして適切なものはどれか。"
    },
    {
      "id": 14,
      "category": "性能・運用",
      "options": [
        "データの完全な複製",
        "データ移行中のサービス可用性とパフォーマンス影響",
        "セキュリティ設定の簡素化",
        "バックアップ容量の削減"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Shardingのリバランシングでは、大量のデータ移行を行うため、サービスの可用性を保ちながらパフォーマンス影響を最小化することが重要な課題です。",
      "level": "上級",
      "text": "Database Sharding における「Rebalancing」の課題として適切なものはどれか。"
    },
    {
      "id": 15,
      "category": "新技術・標準",
      "options": [
        "テーブルスキャンの利用",
        "インデックスと隣接リストの効率的な実装",
        "データの完全な非正規化",
        "JOINの完全な排除"
      ],
      "correctAnswerIndex": 1,
      "explanation": "グラフデータベースでは、ノード間の関係を効率的に辿るため、適切なインデックスと隣接リスト構造の実装が性能の鍵となります。",
      "level": "上級",
      "text": "Graph Database における「Traversal」クエリの最適化で重要な要素はどれか。"
    },
    {
      "id": 16,
      "category": "データベース設計",
      "options": [
        "作成時間と更新時間",
        "Valid Time と Transaction Time",
        "開始時間と終了時間",
        "システム時間とユーザー時間"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Bi-temporalデータベースは、Valid Time（実世界での有効期間）とTransaction Time（データベースでの記録期間）の2つの時間軸を管理します。",
      "level": "上級",
      "text": "Temporal Database における「Bi-temporal」データ管理の2つの時間軸として適切なものはどれか。"
    },
    {
      "id": 17,
      "category": "SQL・クエリ最適化",
      "options": [
        "インデックスの作成速度向上",
        "WHERE条件の一部をストレージエンジンレベルで評価し不要な行読み取りを削減",
        "インデックスサイズの削減",
        "トランザクション処理の高速化"
      ],
      "correctAnswerIndex": 1,
      "explanation": "ICPは、WHERE条件の一部をストレージエンジンレベルで事前評価することで、不要な行の読み取りを削減し、クエリ性能を向上させます。",
      "level": "上級",
      "text": "MySQL の InnoDB におけるIndex Condition Pushdown（ICP）の効果として適切なものはどれか。"
    },
    {
      "id": 18,
      "category": "トランザクション管理",
      "options": [
        "強一貫性のみ",
        "結果整合性（Eventual Consistency）",
        "完全な非一貫性",
        "一貫性は考慮しない"
      ],
      "correctAnswerIndex": 1,
      "explanation": "CAP定理では、Partition ToleranceとAvailabilityを選択した場合、強一貫性を犠牲にして結果整合性を採用することが一般的です。",
      "level": "中級",
      "text": "CAP定理において「Partition Tolerance」を選択した分散データベースシステムで実装される整合性モデルとして適切なものはどれか。"
    },
    {
      "id": 19,
      "category": "性能・運用",
      "options": [
        "クエリのパラメータ化",
        "適切なキャッシュサイズの設定",
        "すべてのクエリを必ずキャッシュする",
        "キャッシュ無効化戦略の明確化"
      ],
      "correctAnswerIndex": 2,
      "explanation": "頻繁に変更されるデータや一度しか実行されないクエリは、キャッシュの効果が低く、むしろメモリリソースの無駄遣いになります。",
      "level": "中級",
      "text": "Database Query Cache の効率性を向上させる設計として適切でないものはどれか。"
    },
    {
      "id": 20,
      "category": "新技術・標準",
      "options": [
        "OLTP処理の高速化",
        "集計クエリでの圧縮効果とI/O削減",
        "行単位更新の高速化",
        "トランザクション分離の強化"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Columnar Storageは、同一データタイプを連続格納することで高い圧縮率を実現し、分析クエリでの読み取りI/Oを大幅に削減します。",
      "level": "上級",
      "text": "Columnar Storage Database の分析処理における利点として適切なものはどれか。"
    },
    {
      "id": 21,
      "category": "データベース設計",
      "options": [
        "すべてのイベント後に必ず作成",
        "一定のイベント数やパフォーマンス要件に基づく定期作成",
        "Snapshot は作成しない",
        "障害発生時のみ作成"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Snapshotは、大量のイベント履歴からの状態復元コストを削減するため、適切な間隔で作成することが重要です。",
      "level": "上級",
      "text": "Event Sourcing におけるSnapshot の作成タイミングとして適切なものはどれか。"
    },
    {
      "id": 22,
      "category": "SQL・クエリ最適化",
      "options": [
        "SELECT文でのみ利用可能",
        "書き込み処理を含むクエリでは制限がある",
        "すべてのクエリが自動的に並列化される",
        "メモリ使用量に影響しない"
      ],
      "correctAnswerIndex": 1,
      "explanation": "PostgreSQLのParallel Queryは主に読み取り処理に最適化されており、書き込み処理や特定の関数を含むクエリでは制限があります。",
      "level": "上級",
      "text": "PostgreSQL における「Parallel Query」実行の制限事項として適切なものはどれか。"
    },
    {
      "id": 23,
      "category": "トランザクション管理",
      "options": [
        "元の操作を完全に元に戻す逆操作",
        "ビジネス的に意味のある補償処理",
        "すべての操作で自動生成可能",
        "データベースレベルでの自動ロールバック"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Sagaの補償アクションは、技術的な逆操作ではなく、ビジネス要件に応じた意味のある補償処理（例：注文キャンセル、在庫復元等）を実装します。",
      "level": "上級",
      "text": "Distributed Transaction における「Sagas Pattern」で使用される補償アクション（Compensating Action）の特徴として適切なものはどれか。"
    },
    {
      "id": 24,
      "category": "性能・運用",
      "options": [
        "SQL 構文の正確性確認",
        "パフォーマンス ボトルネックの特定と分析",
        "セキュリティ監査の実施",
        "バックアップの整合性確認"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Wait Event Analysisは、データベースがどのリソース（I/O、CPU、ロック等）で待機しているかを分析し、パフォーマンスボトルネックを特定します。",
      "level": "中級",
      "text": "Database Monitoring における「Wait Event Analysis」の目的として適切なものはどれか。"
    },
    {
      "id": 25,
      "category": "新技術・標準",
      "options": [
        "バックアップ容量の削減のみ",
        "メモリ速度でのデータ永続化",
        "ネットワーク通信の暗号化",
        "CPU 性能の向上"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Persistent Memory（Intel Optane等）は、DRAM並みの高速アクセスと不揮発性を両立し、高速でのデータ永続化を実現します。",
      "level": "上級",
      "text": "In-Memory Database における「Persistent Memory（PMEM）」の活用効果として適切なものはどれか。"
    },
    {
      "id": 26,
      "category": "データベース設計",
      "options": [
        "データ特性とアクセスパターン",
        "一貫性要件",
        "すべてのデータを単一データストアに集約",
        "スケーラビリティ要件"
      ],
      "correctAnswerIndex": 2,
      "explanation": "Polyglot Persistenceは、異なるデータ特性や要件に応じて最適なデータストア技術を選択・組み合わせるアプローチです。",
      "level": "上級",
      "text": "Polyglot Persistence アーキテクチャにおけるデータストア選択の基準として適切でないものはどれか。"
    },
    {
      "id": 27,
      "category": "SQL・クエリ最適化",
      "options": [
        "Predicate Pushdown",
        "Column Pruning",
        "行レベルセキュリティの無効化",
        "Projection Pushdown"
      ],
      "correctAnswerIndex": 2,
      "explanation": "Catalyst Optimizerは、Predicate Pushdown、Column Pruning等のルールベース最適化を行いますが、セキュリティ機能を無効化することはありません。",
      "level": "上級",
      "text": "Apache Spark SQL における「Catalyst Optimizer」の最適化として適切でないものはどれか。"
    },
    {
      "id": 28,
      "category": "トランザクション管理",
      "options": [
        "Proof of Work（PoW）",
        "Proof of Stake（PoS）",
        "Two-Phase Commit（2PC）",
        "Practical Byzantine Fault Tolerance（pBFT）"
      ],
      "correctAnswerIndex": 2,
      "explanation": "2PCは従来の分散データベースの合意アルゴリズムであり、ブロックチェーンのByzantine fault tolerantな環境での合意メカニズムではありません。",
      "level": "上級",
      "text": "Blockchain Database における「Consensus Mechanism」として適切でないものはどれか。"
    },
    {
      "id": 29,
      "category": "性能・運用",
      "options": [
        "コストに上限がない",
        "物理的なリソース限界とダウンタイムの発生",
        "データの整合性が保証されない",
        "セキュリティが完全に失われる"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Vertical Scalingは、単一インスタンスのリソース増強のため、物理的限界があり、スケールアップ時にダウンタイムが発生する可能性があります。",
      "level": "中級",
      "text": "Database as a Service（DBaaS）における「Vertical Scaling」の限界として適切なものはどれか。"
    },
    {
      "id": 30,
      "category": "新技術・標準",
      "options": [
        "単一システムでの多様なデータ型サポート",
        "データモデル間の関係性表現",
        "すべてのデータモデルで同一の最適化",
        "運用管理の統一化"
      ],
      "correctAnswerIndex": 2,
      "explanation": "Multi-Model Databaseでは、各データモデル（Document、Graph、Key-Value等）に応じた最適化が必要であり、同一の最適化は適切ではありません。",
      "level": "上級",
      "text": "Multi-Model Database の利点として適切でないものはどれか。"
    },
    {
      "id": 31,
      "category": "データベース設計",
      "options": [
        "Aggregate は必ず単一テーブルで実装",
        "Aggregate の境界は トランザクション境界と一致させる",
        "Aggregate は物理的なデータベース分割と無関係",
        "すべてのエンティティを単一Aggregateに含める"
      ],
      "correctAnswerIndex": 1,
      "explanation": "DDDでは、Aggregateの境界をトランザクション境界と一致させることで、データ整合性とビジネス不変条件を効率的に保護します。",
      "level": "上級",
      "text": "Domain-Driven Design における「Aggregate」とデータベース設計の関係として適切なものはどれか。"
    },
    {
      "id": 32,
      "category": "SQL・クエリ最適化",
      "options": [
        "すべてのデータを単一ノードに移動",
        "Co-location とBroadcast JOIN の適切な選択",
        "JOIN の完全な回避",
        "すべてのテーブルの完全複製"
      ],
      "correctAnswerIndex": 1,
      "explanation": "分散データベースでは、データサイズと分散状況に応じて、Co-location（データ配置最適化）やBroadcast JOIN を選択してネットワーク転送を最小化します。",
      "level": "上級",
      "text": "Distributed SQL Database における「Distributed JOIN」の最適化手法として適切なものはどれか。"
    },
    {
      "id": 33,
      "category": "トランザクション管理",
      "options": [
        "中央調整が必須",
        "競合解決なしで自動的にマージ可能",
        "強い一貫性のみサポート",
        "単一ノードでのみ動作"
      ],
      "correctAnswerIndex": 1,
      "explanation": "CRDTは、数学的特性により、分散環境での並行更新が自動的にマージ可能で、競合解決メカニズムを不要にするデータ型です。",
      "level": "上級",
      "text": "CRDT（Conflict-free Replicated Data Type）の特徴として適切なものはどれか。"
    },
    {
      "id": 34,
      "category": "性能・運用",
      "options": [
        "接続の事前検証を一切行わない",
        "定期的なHealth Check クエリの実行",
        "接続プールサイズの固定化",
        "すべての接続を永続的に保持"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Connection Validationでは、「SELECT 1」などの軽量クエリを定期実行し、無効な接続を事前に検出・除去することで安定性を確保します。",
      "level": "中級",
      "text": "Database Connection Pool における「Connection Validation」の実装として適切なものはどれか。"
    },
    {
      "id": 35,
      "category": "新技術・標準",
      "options": [
        "スケーラビリティの制限",
        "コールドスタート遅延と接続管理",
        "高可用性の実現不可",
        "SQL サポートの完全な欠如"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Serverless DBは、使用時の起動遅延（コールドスタート）と、従来の永続的接続モデルとの適合性が主要な課題です。",
      "level": "上級",
      "text": "Serverless Database の課題として適切なものはどれか。"
    },
    {
      "id": 36,
      "category": "データベース設計",
      "options": [
        "中央集権的なデータ管理",
        "ドメイン指向で自己完結的なデータセット",
        "すべてのデータを単一形式で統一",
        "技術チームのみが管理"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Data Meshでは、各ドメインチームが自己完結的なData Productを所有・管理し、ドメイン知識に基づいたデータ提供を実現します。",
      "level": "上級",
      "text": "Data Mesh アーキテクチャにおける「Data Product」の設計原則として適切なものはどれか。"
    },
    {
      "id": 37,
      "category": "SQL・クエリ最適化",
      "options": [
        "カーソルの メモリ使用量削減",
        "パラメータ値の偏りに応じた実行計画の最適化",
        "同時実行性の向上",
        "SQL 構文の自動修正"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Adaptive Cursor Sharingは、バインド変数の値分布に偏りがある場合に、異なる実行計画を作成してパフォーマンスを最適化します。",
      "level": "上級",
      "text": "Oracle Database における「Adaptive Cursor Sharing」の目的として適切なものはどれか。"
    },
    {
      "id": 38,
      "category": "トランザクション管理",
      "options": [
        "単一行の同時更新",
        "異なる行の読み取り結果に基づく別行への書き込み",
        "読み取り専用トランザクション",
        "単一トランザクション内の処理"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Write Skewは、複数トランザクションが異なる行を読み取り、その結果に基づいて別の行を更新することで、ビジネス制約が破られる現象です。",
      "level": "上級",
      "text": "Database における「Write Skew」アノマリーが発生する条件として適切なものはどれか。"
    },
    {
      "id": 39,
      "category": "性能・運用",
      "options": [
        "データ整合性の完全な保証",
        "クエリ性能とストレージ効率の向上",
        "管理の複雑性が完全に解消",
        "バックアップが不要になる"
      ],
      "correctAnswerIndex": 1,
      "explanation": "水平分割（行分割）と垂直分割（列分割）の組み合わせにより、アクセスパターンに応じたクエリ性能とストレージ効率の最適化が可能になります。",
      "level": "中級",
      "text": "Database Partitioning における「Horizontal Partitioning」と「Vertical Partitioning」の組み合わせ効果として適切なものはどれか。"
    },
    {
      "id": 40,
      "category": "新技術・標準",
      "options": [
        "ストレージ容量の物理的な増大",
        "並列検索による指数的な検索速度向上",
        "データの完全な暗号化",
        "ネットワーク遅延の解消"
      ],
      "correctAnswerIndex": 1,
      "explanation": "量子データベースでは、量子の重ね合わせ状態を利用して、複数の検索パスを同時に実行し、特定の問題で指数的な検索速度向上が期待されます。",
      "level": "上級",
      "text": "Quantum Database における「Quantum Superposition」の活用として期待される効果はどれか。"
    },
    {
      "id": 41,
      "category": "データベース設計",
      "options": [
        "過去データの一括処理",
        "リアルタイムデータの低遅延処理",
        "データの長期アーカイブ",
        "マスターデータの管理"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Lambda ArchitectureのSpeed Layerは、ストリーミングデータをリアルタイムで処理し、低遅延でのクエリ応答を提供します。",
      "level": "上級",
      "text": "Lambda Architecture における「Speed Layer」の役割として適切なものはどれか。"
    },
    {
      "id": 42,
      "category": "SQL・クエリ最適化",
      "options": [
        "Star Schemaは非正規化、Snowflake Schemaは正規化されたディメンション",
        "Star Schemaは複雑、Snowflake Schemaは単純",
        "機能的な違いはない",
        "Star Schemaは読み取り専用、Snowflake Schemaは読み書き可能"
      ],
      "correctAnswerIndex": 0,
      "explanation": "Star Schemaはディメンションテーブルを非正規化、Snowflake Schemaはディメンションテーブルを正規化して、階層構造を分離します。",
      "level": "中級",
      "text": "Analytical Database における「Star Schema」と「Snowflake Schema」の主な違いはどれか。"
    },
    {
      "id": 43,
      "category": "トランザクション管理",
      "options": [
        "事前に決められた固定リーダー",
        "ランダム化されたタイムアウトによる分散的リーダー選出",
        "外部システムによるリーダー指定",
        "リーダー選出は行わない"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Raftでは、各ノードがランダム化されたelection timeoutを持ち、タイムアウト後に候補者となってリーダー選出を開始します。",
      "level": "上級",
      "text": "Distributed Consensus において「Raft Algorithm」の Leader Election プロセスの特徴として適切なものはどれか。"
    },
    {
      "id": 44,
      "category": "性能・運用",
      "options": [
        "トランザクションサイズの大型化",
        "適切なインデックス設計とクエリ最適化によるロック数削減",
        "分離レベルの上昇",
        "ロック機能の完全な無効化"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Lock Escalationを防ぐには、効率的なインデックス設計により必要最小限の行のみをロックし、適切なクエリ最適化でロック保持時間を短縮します。",
      "level": "上級",
      "text": "Database Lock Escalation の発生を抑制する手法として適切なものはどれか。"
    },
    {
      "id": 45,
      "category": "新技術・標準",
      "options": [
        "地理的分散配置",
        "低遅延アクセス",
        "中央集権的なデータ管理",
        "ローカルデータ処理能力"
      ],
      "correctAnswerIndex": 2,
      "explanation": "Edge Databaseは、データを中央に集約するのではなく、エッジ（ユーザーやデバイスに近い場所）に分散配置することが特徴です。",
      "level": "上級",
      "text": "Edge Database の特徴として適切でないものはどれか。"
    },
    {
      "id": 46,
      "category": "データベース設計",
      "options": [
        "アプリケーションコードの変更が必要",
        "データベースログを利用したリアルタイム変更検知",
        "バッチ処理のみでの変更検知",
        "手動でのデータ同期が必要"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Log-Based CDCは、データベースのトランザクションログを監視することで、アプリケーション変更なしにリアルタイムでデータ変更を検知します。",
      "level": "上級",
      "text": "Change Data Capture（CDC）における「Log-Based CDC」の利点として適切なものはどれか。"
    },
    {
      "id": 47,
      "category": "SQL・クエリ最適化",
      "options": [
        "分析クエリの高速化",
        "データ圧縮率の向上",
        "OLTP処理の大幅な高速化",
        "Batch Mode Processing の活用"
      ],
      "correctAnswerIndex": 2,
      "explanation": "Columnstore Indexは分析処理（OLAP）に最適化されており、頻繁な行単位更新を伴うOLTP処理には適していません。",
      "level": "上級",
      "text": "SQL Server における「Columnstore Index」の効果として適切でないものはどれか。"
    },
    {
      "id": 48,
      "category": "トランザクション管理",
      "options": [
        "最新の状態のみを保持",
        "特定時点でのシステム状態の再構築",
        "イベントの順序を無視",
        "データの物理削除"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Event Sourcingでは、イベント履歴から任意の過去時点でのシステム状態を再構築するTemporal Queryが重要な機能です。",
      "level": "上級",
      "text": "Event Sourcing における「Temporal Query」の実装として適切なものはどれか。"
    },
    {
      "id": 49,
      "category": "性能・運用",
      "options": [
        "フルバックアップのみ",
        "フルバックアップとトランザクションログの継続的保存",
        "インクリメンタルバックアップのみ",
        "スナップショットのみ"
      ],
      "correctAnswerIndex": 1,
      "explanation": "PITRには、基準点となるフルバックアップと、それ以降のすべてのトランザクションログが必要で、任意時点での状態復元が可能になります。",
      "level": "基礎",
      "text": "Database Backup における「Point-in-Time Recovery（PITR）」の実現に必要な要素はどれか。"
    },
    {
      "id": 50,
      "category": "新技術・標準",
      "options": [
        "CPU負荷の増大",
        "ストレージデバイス内でのデータ処理によるI/O削減",
        "メモリ使用量の増加",
        "ネットワーク帯域幅の増加"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Computational Storageは、ストレージデバイス内にプロセッサーを搭載し、データ移動を最小化してフィルタリングや集計処理を実行します。",
      "level": "上級",
      "text": "Computational Storage における Database Processing の利点として適切なものはどれか。"
    },
    {
      "id": 51,
      "category": "データベース設計",
      "options": [
        "データ独立性の向上",
        "分散トランザクションとデータ整合性の管理",
        "開発効率の大幅向上",
        "運用コストの削減"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Database per Serviceでは、サービス間でのデータ整合性確保と、複数データベースにまたがるトランザクション管理が大きな課題となります。",
      "level": "上級",
      "text": "Microservices における「Database per Service」パターンでの課題として適切なものはどれか。"
    },
    {
      "id": 52,
      "category": "SQL・クエリ最適化",
      "options": [
        "データの完全な複製",
        "スキャン範囲の削減とクエリ性能の向上",
        "ストレージコストの増加",
        "データ整合性の低下"
      ],
      "correctAnswerIndex": 1,
      "explanation": "BigQueryでは、Partitioning（日付等による分割）とClustering（関連データの物理的配置）により、クエリでスキャンするデータ量を大幅に削減できます。",
      "level": "上級",
      "text": "BigQuery における「Partitioning」と「Clustering」の組み合わせ効果として適切なものはどれか。"
    },
    {
      "id": 53,
      "category": "トランザクション管理",
      "options": [
        "ローカルクロックのみ使用",
        "TrueTime API による全世界での時刻同期",
        "単一データセンターでの処理",
        "結果整合性モデルの採用"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Google SpannerはTrueTime APIを使用し、GPS とアトミッククロックによる全世界での時刻同期により、外部一貫性を実現します。",
      "level": "上級",
      "text": "Spanner Database における「External Consistency」の実現メカニズムとして適切なものはどれか。"
    },
    {
      "id": 54,
      "category": "性能・運用",
      "options": [
        "LRU（Least Recently Used）アルゴリズム",
        "アダプティブな プリフェッチ",
        "すべてのデータを常時メモリ保持",
        "ワーキングセットサイズの監視"
      ],
      "correctAnswerIndex": 2,
      "explanation": "すべてのデータをメモリに保持することは、メモリリソースの制約と コストの観点から現実的ではなく、効率的な管理アルゴリズムが必要です。",
      "level": "上級",
      "text": "Database Memory Management における「Buffer Pool」の効率化手法として適切でないものはどれか。"
    },
    {
      "id": 55,
      "category": "新技術・標準",
      "options": [
        "既存システムを統合した統一ビュー",
        "データの物理的な統合が必須",
        "異種データベースの透過的アクセス",
        "分散クエリ処理"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Federated Database Systemは、データを物理的に統合せず、仮想的な統一ビューを提供することで既存システムの自律性を保持します。",
      "level": "上級",
      "text": "Federated Database System の利点として適切でないものはどれか。"
    },
    {
      "id": 56,
      "category": "データベース設計",
      "options": [
        "データの品質評価指標",
        "遅延データの処理タイミングを制御する時刻指標",
        "ストリームのデータ量制限",
        "セキュリティレベルの設定"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Watermarkは、ストリーミングデータ処理において、「この時刻以前のデータは概ね到着済み」を示す指標で、ウィンドウ処理のタイミングを決定します。",
      "level": "上級",
      "text": "Stream Processing Database における「Watermark」の概念として適切なものはどれか。"
    },
    {
      "id": 57,
      "category": "SQL・クエリ最適化",
      "options": [
        "実行時統計に基づく Join 戦略の動的変更",
        "Data Skew の動的検出と調整",
        "クエリ構文の自動修正",
        "動的なPartition 統合"
      ],
      "correctAnswerIndex": 2,
      "explanation": "AQEは実行時の統計情報に基づく最適化を行いますが、SQL構文自体の修正は行わず、実行計画の動的調整を実施します。",
      "level": "上級",
      "text": "Apache Spark における「Adaptive Query Execution（AQE）」の機能として適切でないものはどれか。"
    },
    {
      "id": 58,
      "category": "トランザクション管理",
      "options": [
        "Last Write Wins（LWW）",
        "Vector Clock による因果関係ベース解決",
        "すべての競合を無視",
        "Application-Level Conflict Resolution"
      ],
      "correctAnswerIndex": 2,
      "explanation": "Multi-Master環境では、データ整合性のために適切な競合解決戦略が必須であり、競合を無視することはデータ破損につながります。",
      "level": "上級",
      "text": "Multi-Master Replication における「Conflict Resolution」戦略として適切でないものはどれか。"
    },
    {
      "id": 59,
      "category": "性能・運用",
      "options": [
        "リアクティブなスケーリングのみ",
        "負荷パターンの予測による事前リソース準備",
        "人手による負荷予測が必須",
        "スケーリングの完全な停止"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Predictive Scalingは、過去のパターンや外部要因を分析して負荷を予測し、事前にリソースを準備することで、レスポンス性能を維持します。",
      "level": "上級",
      "text": "Database Auto-Scaling における「Predictive Scaling」の利点として適切なものはどれか。"
    },
    {
      "id": 60,
      "category": "新技術・標準",
      "options": [
        "データの平文処理のみ",
        "Trusted Execution Environment での暗号化データ処理",
        "セキュリティ機能の完全な無効化",
        "パブリックネットワークでの非暗号化通信"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Confidential Computingでは、TEE（Trusted Execution Environment）内で暗号化されたデータを復号・処理し、メモリ上でも保護します。",
      "level": "上級",
      "text": "Confidential Computing における Database の活用として適切なものはどれか。"
    },
    {
      "id": 61,
      "category": "データベース設計",
      "options": [
        "構造化データのみサポート",
        "Data Lake の柔軟性と Data Warehouse の管理機能を統合",
        "バッチ処理のみサポート",
        "単一ファイル形式のみサポート"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Data Lakehouseは、Data Lakeの柔軟性（多様なデータ形式、低コスト）とData Warehouseの管理機能（ACID、スキーマ管理）を統合したアーキテクチャです。",
      "level": "上級",
      "text": "Data Lakehouse アーキテクチャの特徴として適切なものはどれか。"
    },
    {
      "id": 62,
      "category": "SQL・クエリ最適化",
      "options": [
        "ネットワーク転送データ量の増加",
        "データ転送前のローカルフィルタリングによる効率化",
        "CPU使用率の増加",
        "メモリ使用量の増加"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Push-Down Optimizationは、フィルタ条件や集計処理をデータ保存ノードで事前実行し、ネットワーク転送量を削減します。",
      "level": "上級",
      "text": "Distributed Database における「Push-Down Optimization」の効果として適切なものはどれか。"
    },
    {
      "id": 63,
      "category": "トランザクション管理",
      "options": [
        "2 Phase Locking のみ",
        "Read と Write のタイムスタンプを用いた競合検出",
        "ログベースの レプリケーションのみ",
        "楽観的ロックの完全な回避"
      ],
      "correctAnswerIndex": 1,
      "explanation": "CockroachDBのSSIは、読み取りと書き込みのタイムスタンプを比較し、Serializable性を損なう競合を検出してトランザクションを中止します。",
      "level": "上級",
      "text": "CockroachDB における「Serializable Snapshot Isolation」の実装手法として適切なものはどれか。"
    },
    {
      "id": 64,
      "category": "性能・運用",
      "options": [
        "実行時間とCPU使用率",
        "ロック待機時間",
        "アプリケーションのUI応答性",
        "I/O統計情報"
      ],
      "correctAnswerIndex": 2,
      "explanation": "Database Query Performance Insightは、データベース内部のクエリ性能に焦点を当て、UI応答性はアプリケーション層の指標です。",
      "level": "中級",
      "text": "Database Observability における「Query Performance Insight」で監視すべき主要メトリクスとして適切でないものはどれか。"
    },
    {
      "id": 65,
      "category": "新技術・標準",
      "options": [
        "暗号化処理が不可能",
        "限定的な演算サポートと処理性能の低下",
        "セキュリティが完全に失われる",
        "データサイズが削減される"
      ],
      "correctAnswerIndex": 1,
      "explanation": "準同型暗号は、暗号化したままでの計算を可能にしますが、サポートされる演算が限定的で、処理性能も大幅に低下します。",
      "level": "上級",
      "text": "Homomorphic Encryption を Database で活用する場合の制限として適切なものはどれか。"
    },
    {
      "id": 66,
      "category": "データベース設計",
      "options": [
        "イベントサイズの削減",
        "古いイベント形式を新しい形式に変換",
        "イベントの削除",
        "パフォーマンスの低下"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Upcastingは、Event Sourcingにおいてスキーマ進化に対応し、古い形式のイベントを読み取り時に新しい形式に変換する仕組みです。",
      "level": "上級",
      "text": "Event Store の設計において「Upcasting」の目的として適切なものはどれか。"
    },
    {
      "id": 67,
      "category": "SQL・クエリ最適化",
      "options": [
        "実行時統計のみに依存",
        "事前定義されたルールによる論理的なクエリ変換",
        "機械学習による最適化",
        "手動でのクエリ書き換え"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Apache Calciteは、事前定義されたルール（projection pushdown、filter pushdown等）を適用して、論理的にクエリを最適化します。",
      "level": "上級",
      "text": "Apache Calcite における「Rule-Based Optimization」の特徴として適切なものはどれか。"
    },
    {
      "id": 68,
      "category": "トランザクション管理",
      "options": [
        "悲観的並行制御のみ",
        "決定論的トランザクションスケジューリング",
        "2 Phase Commit の必須使用",
        "単一ノードでの処理限定"
      ],
      "correctAnswerIndex": 1,
      "explanation": "CALVINは、トランザクションを決定論的にスケジューリングすることで、分散環境でも一貫性を保ちながら高いスループットを実現します。",
      "level": "上級",
      "text": "FaunaDB における「CALVIN」アルゴリズムの特徴として適切なものはどれか。"
    },
    {
      "id": 69,
      "category": "性能・運用",
      "options": [
        "システム性能の向上",
        "ネットワーク遅延耐性とタイムアウト処理の検証",
        "データ整合性の向上",
        "セキュリティの強化"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Latency Injectionは、意図的にデータベース応答遅延を発生させ、アプリケーションのタイムアウト処理や障害対応を検証します。",
      "level": "上級",
      "text": "Database Chaos Engineering における「Latency Injection」の目的として適切なものはどれか。"
    },
    {
      "id": 70,
      "category": "新技術・標準",
      "options": [
        "クエリ性能の大幅な向上",
        "個人特定リスクを数学的に制御した統計情報提供",
        "データ圧縮率の向上",
        "トランザクション性能の向上"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Differential Privacyは、統計的クエリにノイズを加えることで、個人のプライバシーを数学的に保証しながら有用な統計情報を提供します。",
      "level": "上級",
      "text": "Differential Privacy を Database で実装する際の効果として適切なものはどれか。"
    },
    {
      "id": 71,
      "category": "データベース設計",
      "options": [
        "データサイズの削減",
        "大規模データセットでの効率的な差分管理とマージ競合解決",
        "セキュリティの向上",
        "ネットワーク性能の向上"
      ],
      "correctAnswerIndex": 1,
      "explanation": "データバージョニングでは、大規模データセットの変更差分を効率的に管理し、マージ時の競合を適切に解決することが主要な技術課題です。",
      "level": "上級",
      "text": "Data Versioning システムにおける「Branching and Merging」の Database 実装課題として適切なものはどれか。"
    },
    {
      "id": 72,
      "category": "SQL・クエリ最適化",
      "options": [
        "すべての変更で即座に更新",
        "データ更新頻度とクエリパターンに基づく最適化",
        "更新を一切行わない",
        "手動更新のみ"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Materialized Viewの更新戦略は、ベースデータの更新頻度、クエリアクセスパターン、更新コストを考慮して最適化する必要があります。",
      "level": "中級",
      "text": "Analytical Database における「Materialized View」の自動更新戦略として適切なものはどれか。"
    },
    {
      "id": 73,
      "category": "トランザクション管理",
      "options": [
        "機能的な違いはない",
        "State-basedは状態を同期、Operation-basedは操作を同期",
        "State-basedは高速、Operation-basedは低速",
        "State-basedは分散不可、Operation-basedは分散可能"
      ],
      "correctAnswerIndex": 1,
      "explanation": "State-based CRDTは状態の変更を同期し、Operation-based CRDTは操作（オペレーション）を同期して、結果整合性を保ちます。",
      "level": "上級",
      "text": "CRDTs（Conflict-free Replicated Data Types）における「State-based」と「Operation-based」CRDTの違いとして適切なものはどれか。"
    },
    {
      "id": 74,
      "category": "性能・運用",
      "options": [
        "サービス停止による一括移行",
        "Dual Write とGradual Read Migration による段階的移行",
        "データのコピーのみ",
        "新システムでの完全な再構築"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Zero-Downtime Migrationでは、新旧システムへの並行書き込み（Dual Write）と読み取りの段階的移行により、サービス継続を実現します。",
      "level": "中級",
      "text": "Database Migration における「Zero-Downtime Migration」の実現手法として適切なものはどれか。"
    },
    {
      "id": 75,
      "category": "新技術・標準",
      "options": [
        "レプリケーション遅延の増大",
        "強一貫性とByzantine fault tolerance の実現",
        "ネットワーク帯域幅の無制限使用",
        "単一障害点の増加"
      ],
      "correctAnswerIndex": 1,
      "explanation": "Consensusベースのレプリケーション（Raft、pBFT等）は、分散環境でも強一貫性を保ち、ビザンチン障害への耐性を提供します。",
      "level": "上級",
      "text": "Distributed SQL Database における「Consensus-based Replication」の利点として適切なものはどれか。"
    }
  ]
}
